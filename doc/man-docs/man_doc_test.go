// Copyright Project Harbor Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package main

import (
	"bytes"
	"io/fs"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"testing"

	"github.com/spf13/cobra"
	"github.com/spf13/cobra/doc"
)

func TestCleanManPages(t *testing.T) {
	// basically check if any kind of date and history sections are not present
	dateRgx := regexp.MustCompile(`(?i)\d{0,2}?\s?(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)[a-z]*\s?-?\d{4}`)
	tests := []struct {
		name  string
		setup func(t *testing.T) string
	}{
		{
			name: "Date and history section present, are expected to be cleaned",
			setup: func(t *testing.T) string {
				tempDir := t.TempDir()
				path := filepath.Join(tempDir, "test.1")
				content := `.TH "HARBOR" "1" "Jan 2026" "Harbor Community" "Harbor User Manuals"
.SH NAME
harbor-artifact-delete - delete an artifact
.SH DESCRIPTION
delete an artifact
.SH HISTORY
Jan 2026, auto-generated by cobra`

				if err := os.WriteFile(path, []byte(content), 0600); err != nil {
					t.Fatalf("Failed to write test content to temp directory: %v", err)
				}
				return tempDir
			},
		},
		{
			name: "Multiple files in directory",
			setup: func(t *testing.T) string {
				tempDir := t.TempDir()
				files := map[string]string{
					"file1.1": `.TH "HARBOR" "1" "Jan 2026" "Harbor Community" "Harbor User Manuals"
.SH NAME
test1
.SH HISTORY
Jan 2026, auto-generated`,
					"file2.1": `.TH "HARBOR" "1" "Feb 2026" "Harbor Community" "Harbor User Manuals"
.SH NAME
test2
.SH HISTORY
Feb 2026, auto-generated`,
				}
				for name, content := range files {
					path := filepath.Join(tempDir, name)
					if err := os.WriteFile(path, []byte(content), 0600); err != nil {
						t.Fatalf("Failed to write %s: %v", name, err)
					}
				}
				return tempDir
			},
		},
		{
			name: "Empty file",
			setup: func(t *testing.T) string {
				tempDir := t.TempDir()
				path := filepath.Join(tempDir, "empty.1")
				if err := os.WriteFile(path, []byte(""), 0600); err != nil {
					t.Fatalf("Failed to write empty file: %v", err)
				}
				return tempDir
			},
		},
		{
			name: "TH header with less than 5 fields",
			setup: func(t *testing.T) string {
				tempDir := t.TempDir()
				path := filepath.Join(tempDir, "short-header.1")
				content := `.TH "HARBOR" "1"
.SH NAME
short header test
.SH HISTORY
Jan 2026, auto-generated`
				err := os.WriteFile(path, []byte(content), 0600)
				if err != nil {
					t.Fatalf("Failed to write test content: %v", err)
				}
				return tempDir
			},
		},
		{
			name: "Non-.1 files should be ignored",
			setup: func(t *testing.T) string {
				tempDir := t.TempDir()
				path := filepath.Join(tempDir, "readme.txt")
				content := `.TH "HARBOR" "1" "Jan 2026" "Harbor Community" "Harbor User Manuals"
.SH HISTORY
Jan 2026, should not be cleaned`
				err := os.WriteFile(path, []byte(content), 0600)
				if err != nil {
					t.Fatalf("Failed to write test content: %v", err)
				}
				return tempDir
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tempDir := tt.setup(t)
			err := cleanManPages(tempDir)
			if err != nil {
				t.Fatalf("cleanManPages() failed: %v", err)
			}
			err = filepath.Walk(tempDir, func(path string, info fs.FileInfo, err error) error {
				if err != nil {
					return err
				}
				if !info.IsDir() {
					data, err := os.ReadFile(path)
					if err != nil {
						t.Fatalf("Error reading the test file: %v", err)
					}
					content := string(data)

					if strings.HasSuffix(info.Name(), ".1") {
						// .1 files should have dates and history removed
						if dateRgx.MatchString(content) {
							t.Errorf("File %s: Expected not to find any dates but found: %s", info.Name(), content)
						}
						if strings.Contains(content, ".SH HISTORY") {
							t.Errorf("File %s: Found '.SH HISTORY' in cleaned content, expected it to be removed.\nContent: %s", info.Name(), content)
						}
					} else {
						// Non-.1 files should remain unchanged
						if !strings.Contains(content, ".SH HISTORY") {
							t.Errorf("File %s: Expected .SH HISTORY to remain in non-.1 file but it was removed", info.Name())
						}
					}
				}
				return nil
			})
			if err != nil {
				t.Fatalf("Error walking the directory: %v", err)
			}
		})
	}
}
func TestManDoc(t *testing.T) {
	tempDir := t.TempDir()
	originalDir, err := os.Getwd()
	if err != nil {
		t.Fatalf("Error getting the current directory: %v", err)
	}
	defer func() {
		if err := os.Chdir(originalDir); err != nil {
			t.Fatalf("Error changing to original directory: %v", err)
		}
	}()
	if err := os.Chdir(tempDir); err != nil {
		t.Fatalf("Error changing to testing directory: %v", err)
	}
	checkOrder := ""
	mockGenerator := func(cmd *cobra.Command, header *doc.GenManHeader, dir string) error {
		checkOrder += "generator"
		if header.Title != "HARBOR" {
			t.Errorf(`Expected header title to be "HARBOR" but found %s`, header.Title)
		}
		if header.Section != "1" {
			t.Errorf(`Expected header section to be "1" but found %s`, header.Section)
		}
		if header.Source != "Harbor Community" {
			t.Errorf(`Expected header source to be "Harbor Community" but found %s`, header.Source)
		}
		if header.Manual != "Harbor User Manuals" {
			t.Errorf(`Expected header manual to be "Harbor User Manuals" but found %s`, header.Manual)
		}
		return nil
	}
	mockCleaner := func(docDir string) error {
		checkOrder += "cleaner"
		return nil
	}
	var buf bytes.Buffer
	if err = ManDoc(&buf, mockGenerator, mockCleaner); err != nil {
		t.Fatalf("ManDoc() failed to execute: %v", err)
	}
	if checkOrder != "generatorcleaner" {
		t.Errorf("Expected call order 'generatorcleaner' but got %q", checkOrder)
	}

	output := buf.String()
	if !strings.Contains(output, "Documentation generated successfully") {
		t.Errorf("Missing success message in output. Got: %q", output)
	}
	expectedDir := filepath.Join(tempDir, "man-docs/man1")
	if _, err := os.Stat(expectedDir); os.IsNotExist(err) {
		t.Errorf("Expected directory %s to be created but it doesn't exist", expectedDir)
	}
}
